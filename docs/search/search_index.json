{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AdapterFast, fearless styling for Web Components.","text":"<p>         Adapter isolates CSS automatically so your UI survives every embed, extension, and AI-generated page.         No new syntax, no bundle weight, just custom elements that always look right.       </p> Getting Started Core Concepts Framework Integration ~2 kB gzipped No build step required Works in Browser, Deno, Node CSS that never collides <p>Per-class and per-instance constructable style sheets keep host CSS out and your rules in.</p> Drop into any stack <p>React, Vue, Svelte, Lit, Deno, Bun, or plain JS - Adapter is framework-agnostic and zero-dependency.</p> Design-system ready <p>Compose tokens and variants with normal CSS. Inherit styles the same way you inherit classes.</p> Built for embeds <p>Ship widgets, plugins, dashboards, and AI surfaces without worrying about hostile global CSS.</p> Code that feels familiar TypeScript<pre><code>import { Adapter } from \"https://cdn.jsdelivr.net/npm/@devcapsule/adapter/+esm\";\n\nclass Button extends Adapter {}\n\nButton.css = `\n  display: inline-flex;\n  gap: 0.5rem;\n  align-items: center;\n  padding: 0.7rem 1.1rem;\n  border-radius: 999px;\n  border: 1px solid color-mix(in srgb, var(--accent, #22d3ee) 60%, transparent);\n  background: color-mix(in srgb, var(--accent, #22d3ee) 18%, #0b1224);\n  color: #e6edff;\n\n  &amp;[kind=\"ghost\"] {\n    background: transparent;\n  }\n`;\n\nButton.define(\"ui-button\");\n</code></pre> What you get <ul> <li>Encapsulated class-level CSS shared by every instance.</li> <li>Per-instance overrides via the `css` property or attribute.</li> <li>Composable helpers for tokens and variants - no new syntax.</li> <li>Ready-to-embed components that ignore hostile host CSS.</li> </ul>"},{"location":"contribution/development/","title":"AI Development Guide for Adapter","text":"<p>This project is intentionally structured so AI tools can safely help maintain and extend it.</p>"},{"location":"contribution/development/#goals","title":"Goals","text":"<ul> <li>Keep the public API of <code>Adapter</code> stable and well-documented.</li> <li>Prefer small, focused changes with tests.</li> <li>Preserve compatibility with Browser, Deno, and Node environments.</li> <li>Keep the core runtime small and dependency-light.</li> </ul>"},{"location":"contribution/development/#repo-overview-for-ai-tools","title":"Repo Overview (for AI tools)","text":"<ul> <li><code>src/</code> \u2013 Core TypeScript source for Adapter.</li> <li><code>test-src/</code> \u2013 Tests and examples.</li> <li><code>readme.md</code> \u2013 High-level overview and quickstart.</li> <li><code>dev-guide/docstring.md</code> \u2013 Docstring style and conventions.</li> <li><code>deno.json</code> \u2013 Deno tasks for build/test/docs.</li> </ul> <p>When modifying or adding code:</p> <ol> <li>Prefer editing existing files in <code>src/</code> over adding new top-level modules.</li> <li>Keep functions and classes small and composable.</li> <li>Follow existing naming and coding style.</li> </ol>"},{"location":"contribution/development/#tasks-style","title":"Tasks Style","text":"<p>When the user asks an AI tool to work on this repo, tasks should be phrased like:</p> <ul> <li>\"Add a new helper to Adapter to support X, without breaking the existing API.\"</li> <li>\"Refactor this part of the style composition for readability.\"</li> <li>\"Add tests for a specific file or function.\"</li> </ul> <p>AI output should ideally include:</p> <ul> <li>Focused, PR-sized changes.</li> <li>Clear explanation of modifications.</li> <li>Updated or new tests.</li> </ul>"},{"location":"contribution/development/#testing-build","title":"Testing &amp; Build","text":"<p>AI tools should expect:</p> Bash<pre><code>deno task test\ndeno task dist\n</code></pre> <p>If tests cannot be executed, AI tools should:</p> <ul> <li>Avoid altering public API signatures without necessity.</li> <li>Keep changes isolated.</li> </ul>"},{"location":"contribution/development/#documentation-docstrings","title":"Documentation &amp; Docstrings","text":"<p>Follow the guidelines in <code>docstring_guide.md</code>:</p> <ul> <li>Short summary.</li> <li>Parameters with types.</li> <li>Return type.</li> <li>Edge cases or relevant notes.</li> </ul>"},{"location":"contribution/development/#change-safety-rules","title":"Change Safety Rules","text":"<p>AI tools should:</p> <ol> <li>Prefer additive changes over breaking changes.</li> <li>Keep public APIs documented.</li> <li>Update examples if behaviour changes.</li> <li>Avoid introducing new dependencies unless requested.</li> </ol>"},{"location":"contribution/docstring/","title":"Adapter Docstring Guide","text":"<p>This project follows the NumPy Docstring Standard for documenting classes, methods, and functions.</p> <p>NumPy docstrings are widely considered the clearest and most human\u2011friendly scientific documentation style \u2014 and they work extremely well for JavaScript/TypeScript projects when adapted with Markdown.</p> <p>For full reference, see the official spec:</p> <ul> <li>NumPy Documentation: https://numpydoc.readthedocs.io/en/latest/format.html</li> <li>NumPy Docstring Guide: https://numpydoc.readthedocs.io/en/latest/example.html</li> </ul>"},{"location":"contribution/docstring/#purpose","title":"Purpose","text":"<ul> <li>Provide a consistent, readable docstring format across the project.</li> <li>Make Adapter's API easy to understand for contributors.</li> <li>Enable future tooling (AI-assisted docs, extraction scripts, etc.) to parse documentation reliably.</li> <li>Reduce token usage by avoiding JSON-heavy or overly verbose structures.</li> </ul>"},{"location":"contribution/docstring/#general-rules","title":"General Rules","text":"<ol> <li>Use block comments: <code>/** ... */</code> above classes, methods, and functions.</li> <li>Start with a one-line summary.</li> <li>Write in plain English, concise and factual.</li> <li> <p>Use section headers inspired by Numpydoc:</p> </li> <li> <p>Summary (implicit first line)</p> </li> <li>Parameters</li> <li>Returns</li> <li>Raises</li> <li>Examples</li> <li>Notes</li> <li>See Also</li> <li>Use Markdown formatting inside docstrings whenever needed.</li> <li>Avoid embedding JSON-like structures inside docstrings.</li> <li>Keep examples small and directly relevant.</li> </ol>"},{"location":"contribution/docstring/#recommended-template","title":"Recommended Template","text":"TypeScript<pre><code>/**\n * Short summary describing what this class/function does.\n *\n * Parameters\n * ----------\n * name : type\n *     Description of the parameter.\n * value : type, optional\n *     Optional parameter.\n *\n * Returns\n * -------\n * type\n *     Description of return value.\n *\n * Raises\n * ------\n * ErrorType\n *     When and why this error occurs.\n *\n * Examples\n * --------\n * ```ts\n * // Example usage\n * const x = something();\n * ```\n *\n * Notes\n * -----\n * Additional details or special behaviors.\n *\n * See Also\n * --------\n * OtherFunction : Description\n */\n</code></pre>"},{"location":"contribution/docstring/#example-class-documentation","title":"Example: Class Documentation","text":"TypeScript<pre><code>/**\n * Base class for all Adapter-powered custom elements.\n *\n * Notes\n * -----\n * This class provides core styling, registration, and scoping logic.\n */\nexport class Adapter {\n  ...\n}\n</code></pre>"},{"location":"contribution/docstring/#example-method-documentation","title":"Example: Method Documentation","text":"TypeScript<pre><code>/**\n * Register the custom element with the browser.\n *\n * Parameters\n * ----------\n * tagName : string\n *     The tag name used for the custom element.\n * options : DefineOptions, optional\n *     Configuration for scoping, lifecycle, or extensions.\n *\n * Returns\n * -------\n * void\n *     This method does not return a value.\n *\n * Raises\n * ------\n * TypeError\n *     If `tagName` is not valid.\n *\n * Examples\n * --------\n * ```ts\n * class Card extends Adapter {}\n * Card.define(\"el-card\");\n * ```\n */\nstatic define(tagName: string, options?: DefineOptions) {\n  ...\n}\n</code></pre>"},{"location":"contribution/docstring/#writing-tips","title":"Writing Tips","text":""},{"location":"contribution/docstring/#be-concise","title":"Be concise","text":"<p>The first line should summarize purpose clearly.</p>"},{"location":"contribution/docstring/#prefer-natural-language-over-technical-noise","title":"Prefer natural language over technical noise","text":"<p>Good docstrings are short, readable, and helpful.</p>"},{"location":"contribution/docstring/#use-markdown","title":"Use Markdown","text":"<p>Tables, code blocks, inline code (<code>like this</code>) are allowed.</p>"},{"location":"contribution/docstring/#keep-headings-exact","title":"Keep headings exact","text":"<p>Extraction scripts depend on predictable section names:</p> <ul> <li><code>Parameters</code></li> <li><code>Returns</code></li> <li><code>Raises</code></li> <li><code>Examples</code></li> <li><code>Notes</code></li> <li><code>See Also</code></li> </ul>"},{"location":"contribution/docstring/#treat-docstrings-like-public-api","title":"Treat docstrings like public API","text":"<p>Even internal methods benefit from clear explanation.</p>"},{"location":"contribution/docstring/#future-extensions","title":"Future Extensions","text":"<p>This guide may support additional sections in the future:</p> <ul> <li>Attributes \u2013 For classes with exposed properties.</li> <li>Events \u2013 For custom element emission patterns.</li> <li>Lifecycle \u2013 For Adapter-specific callbacks.</li> <li>Constraints \u2013 For validator or parser components.</li> </ul>"},{"location":"contribution/docstring/#extraction-pipeline-optional","title":"Extraction Pipeline (Optional)","text":"<p>If using a custom extraction tool, it will:</p> <ol> <li>Scan <code>src/</code> for <code>/** ... */</code> blocks.</li> <li>Identify sections using headings.</li> <li>Generate Markdown or structured data for AI tools.</li> </ol> <p>This guide is designed so extraction remains simple and robust.</p>"},{"location":"contribution/docstring/#final-notes","title":"Final Notes","text":"<ul> <li>This is the official docstring format for Adapter.</li> <li>All contributors should follow this guide for consistency.</li> <li>Suggestions for improvement are welcome as Adapter evolves.</li> </ul>"},{"location":"contribution/overview/","title":"Adapter Dev Guide \u2013 Overview","text":"<p>This folder contains development notes for humans and AI tools working on Adapter.</p>"},{"location":"contribution/overview/#what-is-adapter","title":"What is Adapter?","text":"<p>Adapter is a lightweight CSS-in-JS toolkit for Web Components. It focuses on:</p> <ul> <li>Styling custom elements using plain JavaScript/TypeScript.</li> <li>Scoped, composable CSS for Web Components and Shadow DOM.</li> <li>A tiny, framework-agnostic runtime that runs in Browser, Deno, and Node.</li> </ul> <p>For a user-facing introduction, see the main <code>readme.md</code>.</p>"},{"location":"contribution/overview/#repository-layout","title":"Repository Layout","text":"<ul> <li><code>src/</code> \u2013 Core TypeScript source code for Adapter.</li> <li><code>test-src/</code> \u2013 Tests, experiments, and examples.</li> <li><code>esbuild/</code> \u2013 Build scripts and bundling configs (browser / Node bundles).</li> <li><code>dev-guide/</code> \u2013 Development docs (this folder).</li> <li><code>deno.json</code> \u2013 Deno tasks for build, test, docs.</li> <li><code>package.json</code> \u2013 npm metadata and legacy tooling.</li> <li><code>changelog.md</code> \u2013 Version history.</li> <li><code>LICENSE.md</code> \u2013 License.</li> </ul>"},{"location":"contribution/overview/#design-philosophy","title":"Design Philosophy","text":"<ul> <li>Web Components first \u2013 The primary target is custom elements + Shadow DOM.</li> <li>Tiny and predictable \u2013 Avoid heavy dependencies and surprising magic.</li> <li>CSS is data \u2013 Treat CSS as composable strings, not opaque blobs.</li> <li>Stable base class \u2013 <code>Adapter</code> should remain stable and well-documented.</li> <li>Multi-runtime \u2013 Behaviour should be consistent across Browser, Deno, Node.</li> </ul>"},{"location":"contribution/overview/#how-to-read-the-rest-of-dev-guide","title":"How to Read the Rest of Dev Guide","text":"<ul> <li><code>workflows.md</code> - Build, test, docs commands.</li> <li><code>docstring.md</code> - Docstring style guide and rules: TSDoc/JSDoc conventions, required tags, examples, and policies for documenting APIs.</li> <li><code>development.md</code> - AI Development Guide: goals, repo overview, task style for AI/human contributors, testing/build expectations, docstring policy, and change-safety rules to keep changes small, focused, and non\u2011breaking.</li> </ul>"},{"location":"contribution/workflow/","title":"Workflows","text":"<p>This file describes how to build, test, and release Adapter.</p>"},{"location":"contribution/workflow/#prerequisites","title":"Prerequisites","text":"<ul> <li>Deno</li> <li>Git</li> <li>Optional: Node.js + npm</li> </ul>"},{"location":"contribution/workflow/#setup","title":"Setup","text":"Bash<pre><code>git clone https://github.com/keenlycode/adapter.git\ncd adapter\nnpm install # optional\n</code></pre>"},{"location":"contribution/workflow/#build","title":"Build","text":"Bash<pre><code>deno task dist\n</code></pre> <p>Outputs go to <code>dist/</code>.</p>"},{"location":"contribution/workflow/#test","title":"Test","text":"Bash<pre><code>deno task test\n# or\nnpm test\n</code></pre>"},{"location":"contribution/workflow/#docs-if-configured","title":"Docs (if configured)","text":"Bash<pre><code>deno task docs\n</code></pre> <p>If this task does nothing yet, it\u2019s safe to ignore.</p>"},{"location":"usage/core-concepts/","title":"Core Concepts","text":"<p>This chapter focuses on how to think about Adapter CSS, not on internal classes or framework APIs.</p> <p>If you understand the ideas below, you can use Adapter comfortably in any project.</p>"},{"location":"usage/core-concepts/#1-class-object","title":"1. Class &amp; Object","text":"<p>Adapter treats styling the same way JavaScript treats objects and classes:</p> <ul> <li>Class-level style \u2013 what every instance of a component shares.</li> <li>Object-level style \u2013 what only one specific instance should have.</li> </ul> <p>You work with two simple layers:</p> <ul> <li>On the class (<code>MyElement</code>):</li> <li><code>static css</code> \u2192 the default look for all instances.</li> <li> <p>optional extra class styles (conceptually similar to \u201cvariants\u201d or \u201cthemes\u201d).</p> </li> <li> <p>On the object (<code>myElement</code>):</p> </li> <li><code>myElement.css</code> or the <code>css</code> attribute \u2192 one-off overrides for that element.</li> </ul> <p>Think of it like this:</p> <ul> <li>The class defines what this kind of thing looks like.</li> <li>Each object can say and here is how I am a little different.</li> </ul> <p>This is the core mental model for Adapter: one shared, reusable style definition plus optional per-instance customization.</p> <p>Example:</p> TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n\nclass Card extends Adapter {\n  // Class-level style: shared by all &lt;ui-card&gt; elements.\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid rgba(0, 0, 0, 0.12);\n    background: white;\n  `;\n}\n\nCard.define(\"ui-card\");\n\n// Later, for one specific card instance:\nconst special = document.createElement(\"ui-card\") as Card;\n\n// Object-level style: applies only to this element.\nspecial.css = `border-color: hotpink;`;\n\ndocument.body.append(special);\n</code></pre>"},{"location":"usage/core-concepts/#2-adaptermixin-compose-with-existing-bases","title":"2. AdapterMixin (compose with existing bases)","text":"<p><code>Adapter</code> is a ready-to-use base class, but sometimes you already have your own element base (for focus management, accessibility helpers, framework mixins, etc.). <code>AdapterMixin</code> lets you add Adapter\u2019s styling model to any HTMLElement subclass without changing the rest of your inheritance chain.</p> <p>When to reach for it:</p> <ul> <li>You already have a base element with lifecycle logic and want Adapter\u2019s styling on top.</li> <li>You need Adapter behavior on a subclass of a framework/base class that itself extends <code>HTMLElement</code>.</li> <li>You want to keep a single inheritance chain instead of introducing a new root class.</li> </ul> <p>Usage pattern:</p> TypeScript<pre><code>import { AdapterMixin } from \"@devcapsule/adapter\";\n\n// Your existing base class with behavior you need to keep.\nclass Focusable extends HTMLElement {\n  connectedCallback() {\n    super.connectedCallback?.();\n    this.tabIndex = 0;\n  }\n}\n\n// Add Adapter features via the mixin.\nclass IconButton extends AdapterMixin(Focusable) {\n  static css = `\n    display: inline-flex;\n    gap: 0.25rem;\n    align-items: center;\n    padding: 0.5rem 0.75rem;\n    border-radius: 999px;\n    background: #111827;\n    color: white;\n  `;\n}\n\nIconButton.define(\"ui-icon-button\"); // Same define step as Adapter\n\n// Extends normally and inherits styles just like Adapter-based classes.\nclass PrimaryIconButton extends IconButton {\n  static css = `\n    background: #2563eb;\n  `;\n}\n\nPrimaryIconButton.define(\"ui-primary-icon-button\");\n</code></pre> <p>Things to remember:</p> <ul> <li><code>AdapterMixin</code> classes expose the same API as <code>Adapter</code> (<code>static css</code>, <code>addStyle</code>, instance <code>css</code>, etc.).</li> <li>Call <code>.define(tagName)</code> (or <code>customElements.define</code>) on each class you want registered.</li> <li>Inheritance works the same way: subclasses pick up parent styles and can add their own.</li> </ul>"},{"location":"usage/core-concepts/#3-css-inheritance","title":"3. CSS Inheritance","text":"<p>Adapter lets CSS follow your JavaScript inheritance.</p> <p>When you extend a component class, the child automatically inherits the parent\u2019s styles, then can add or override its own.</p> <p>Example idea:</p> <ul> <li><code>BaseCard</code> defines layout, padding, and typography.</li> <li><code>InfoCard</code> extends <code>BaseCard</code> and only adds accent colors.</li> <li><code>WarningCard</code> extends <code>BaseCard</code> and only changes borders and background.</li> </ul> <p>Conceptually:</p> <ul> <li>You no longer copy-paste CSS between components.</li> <li>Style reuse happens the same way as method reuse: by extending classes.</li> <li>If you change <code>BaseCard</code>\u2019s CSS, every card that extends it automatically picks up the change.</li> </ul> <p>Adapter takes care of merging inherited styles in the right order so that more specific components win over base components, just like you would expect.</p> <p>Example:</p> TypeScript<pre><code>class BaseCard extends Adapter {\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid rgba(0, 0, 0, 0.12);\n    background: white;\n  `;\n}\n\nBaseCard.define(\"base-card\");\n\n// Inherits BaseCard styles, then adds its own.\nclass InfoCard extends BaseCard {\n  static css = `\n    border-color: #2563eb;\n  `;\n}\n\nInfoCard.define(\"info-card\");\n\n// Also inherits BaseCard styles, but uses different accents.\nclass WarningCard extends BaseCard {\n  static css = `\n    border-color: #f97316;\n    background: #fffbeb;\n  `;\n}\n\nWarningCard.define(\"warning-card\");\n</code></pre> <p>If you later change the padding or typography in <code>BaseCard.css</code>, both <code>info-card</code> and <code>warning-card</code> will update automatically.</p>"},{"location":"usage/core-concepts/#4-programmable-css","title":"4. Programmable CSS","text":"<p>With Adapter, CSS is not a static file; it is data you can compute.</p> <p>You still write normal CSS syntax, but you can:</p> <ul> <li>Build CSS strings from variables and functions.</li> <li>Share token helpers (colors, spacing, radii) across components.</li> <li>Turn repeated patterns into small utilities.</li> </ul> <p>Typical patterns:</p> <ul> <li>Tokens in code \u2013 define <code>primaryColor</code>, spacing scales, or font sizes in JS/TS and interpolate them into your CSS.</li> <li>Composable snippets \u2013 write small functions that return CSS snippets for things like buttons or cards, and reuse them in multiple components.</li> <li>Conditional styles \u2013 decide which CSS to include based on environment, feature flags, or props, then assign the resulting string to <code>static css</code> or <code>element.css</code>.</li> </ul> <p>The key idea: you keep full control over CSS syntax, while JavaScript helps you generate, reuse, and organize it.</p> <p>Example:</p> TypeScript<pre><code>const primary = \"#2563eb\";\nconst radius = \"999px\";\n\n// Reusable snippet for any pill-shaped button.\nconst pillButton = (bg: string, color: string) =&gt; `\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0.5rem 1rem;\n  border-radius: ${radius};\n  background: ${bg};\n  color: ${color};\n`;\n\nclass PrimaryButton extends Adapter {\n  static css = pillButton(primary, \"white\");\n}\n\nPrimaryButton.define(\"ui-primary-button\");\n</code></pre> <p>You can build larger design systems out of small helpers like <code>pillButton</code>, without sacrificing readable CSS.</p>"},{"location":"usage/core-concepts/#5-class-level-css-processors-adaptercssprocessor","title":"5. Class-level CSS processors (<code>adapter.cssProcessor</code>)","text":"<p>Adapter lets you run a single processor for all class-level CSS on a component. Set <code>MyComponent.adapter.cssProcessor</code> to any tagged template function; Adapter will call it when compiling the shared stylesheet for that class (including inherited styles).</p> <ul> <li>It runs only for class-level CSS (<code>static css</code>, <code>addStyle</code>, inherited blocks).</li> <li>Per-instance styles set via <code>element.css</code> bypass this hook.</li> <li>Set it before calling <code>define()</code>.</li> </ul> <p>Example: minify class CSS while leaving instance overrides untouched.</p> TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n\nconst minify = (strings: TemplateStringsArray, ...values: unknown[]) =&gt; {\n  const raw = String.raw({ raw: strings }, ...values);\n  return raw.replace(/\\s+/g, \" \").trim();\n};\n\nclass Tag extends Adapter {}\nTag.adapter.cssProcessor = minify;\n\nTag.css = `\n  display: inline-flex;\n  align-items: center;\n  gap: 0.25rem;\n  padding: 0.25rem 0.5rem;\n  border-radius: 999px;\n  background: #0f172a;\n  color: white;\n`;\n\nTag.define(\"ui-tag\");\n</code></pre> <p>This hook is handy for cross-cutting transforms (token substitution, prefixing, minification) that you want applied to the component\u2019s shared stylesheet without changing how you write CSS in each assignment.</p>"},{"location":"usage/core-concepts/#6-style-isolation","title":"6. Style Isolation","text":"<p>Adapter\u2019s main promise is: your component styles do not collide with anything else.</p> <p>Conceptually, each component gets two protected layers of styling:</p> <ul> <li>A shared sheet for the component class \u2013 holds the baseline design for that tag.</li> <li>A per-instance sheet \u2013 holds overrides for a single element.</li> </ul> <p>These sheets are attached using modern browser features so that:</p> <ul> <li>Global CSS from the host page cannot unexpectedly override your component styles.</li> <li>Styles you write for Adapter components do not leak out and affect the rest of the page.</li> <li>Even if components are injected into unknown or \u201cmessy\u201d environments (dashboards, CMSes, AI-generated pages), they keep looking the way you designed them.</li> </ul> <p>When you think \u201cstyle isolation\u201d with Adapter, think small CSS islands: each component and each instance has its own safe space where rules are applied and resolved.</p> <p>Example (host page with its own global styles):</p> HTML<pre><code>&lt;style&gt;\n  /* Host page styles that would normally leak everywhere */\n  body {\n    font-family: system-ui;\n  }\n\n  .card {\n    border: 10px solid red; /* very aggressive */\n  }\n&lt;/style&gt;\n\n&lt;ui-card&gt;\n  &lt;h2 class=\"card\"&gt;Adapter card&lt;/h2&gt;\n  &lt;p&gt;The host's .card class will not override the component's own rules.&lt;/p&gt;\n&lt;/ui-card&gt;\n</code></pre> <p>Adapter writes your <code>ui-card</code> styles into isolated style sheets so that the host page\u2019s <code>.card</code> rules cannot unexpectedly change your component\u2019s appearance.</p>"},{"location":"usage/core-concepts/#7-use-with-shadow-dom","title":"7. Use with Shadow DOM","text":"<p>Adapter works well whether you use Shadow DOM or not.</p>"},{"location":"usage/core-concepts/#without-shadow-dom","title":"Without Shadow DOM","text":"<p>If your components render in the light DOM (no <code>shadowRoot</code>), Adapter still gives you:</p> <ul> <li>Isolation from global styles via its constructable style sheets.</li> <li>A clean way to style internal markup with familiar selectors.</li> </ul> <p>In many projects, this is enough: you get encapsulated styling without changing how your markup is structured.</p>"},{"location":"usage/core-concepts/#with-shadow-dom","title":"With Shadow DOM","text":"<p>If you also use Shadow DOM, Adapter complements it rather than replacing it:</p> <ul> <li>Shadow DOM controls which DOM nodes are visible and how slotting works.</li> <li>Adapter controls how CSS is organized and scoped to your elements.</li> </ul> <p>In practice, this means:</p> <ul> <li>You can mount Adapter-based elements inside a shadow root; Adapter will attach its style sheets to that root.</li> <li>You can still use <code>::part</code>, <code>::slotted</code>, and other Shadow DOM features alongside Adapter\u2019s class-level and instance-level styles.</li> </ul> <p>You choose how much isolation you need:</p> <ul> <li>Only Adapter \u2192 simpler DOM, strong style isolation.</li> <li>Adapter + Shadow DOM \u2192 maximum isolation for both DOM structure and styles.</li> </ul> <p>Example: using Adapter components inside another element\u2019s shadow root:</p> TypeScript<pre><code>// Define an Adapter-based card somewhere in your app.\nclass ShellCard extends Adapter {\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid rgba(0, 0, 0, 0.12);\n  `;\n}\n\nShellCard.define(\"shell-card\");\n\n// A host element that uses Shadow DOM.\nclass Shell extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: \"open\" });\n    shadow.innerHTML = `\n      &lt;shell-card&gt;\n        &lt;h2&gt;Inside a shadow root&lt;/h2&gt;\n        &lt;p&gt;Card styles are still isolated and applied correctly.&lt;/p&gt;\n      &lt;/shell-card&gt;\n    `;\n  }\n}\n\ncustomElements.define(\"app-shell\", Shell);\n</code></pre> <p>Here, <code>shell-card</code> lives inside <code>app-shell</code>\u2019s shadow root, and Adapter attaches its style sheets to that root instead of the global document.</p>"},{"location":"usage/core-concepts/#8-putting-it-together","title":"8. Putting it together","text":"<p>When you design with Adapter, keep these questions in mind:</p> <ul> <li>Class or object? \u2013 Is this a reusable style (class) or a one-off tweak (object)?</li> <li>Should this be inherited? \u2013 If multiple components share a look, make a base class and let CSS flow down.</li> <li>Can I compute this? \u2013 If you see repetition, extract tokens or helper functions and generate the CSS.</li> <li>Is this isolated enough? \u2013 Remember that Adapter gives you per-component and per-instance islands, and you can add Shadow DOM when you need structural isolation too.</li> </ul> <p>These concepts matter more than any single API. Once you think in terms of class vs object, inheritance, programmable CSS, isolation, and Shadow DOM compatibility, Adapter becomes a flexible, predictable way to style Web Components in any environment.</p>"},{"location":"usage/framework-integration/","title":"Framework Integration","text":"<p>Adapter components are just Web Components. This means they work in many environments with minimal glue code.</p> <p>This chapter shows how to use Adapter-based elements in:</p> <ul> <li>Vanilla JS / HTML</li> <li>React</li> <li>Vue</li> <li>Svelte</li> </ul>"},{"location":"usage/framework-integration/#1-vanilla-js-html","title":"1. Vanilla JS / HTML","text":"<p>The vanilla setup is the most direct: import <code>Adapter</code>, define your element, then use it in HTML.</p> TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n\nclass Card extends Adapter {\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid currentColor;\n  `;\n}\n\nCard.define(\"ui-card\");\n</code></pre> HTML<pre><code>&lt;ui-card&gt;\n  &lt;h2&gt;Hello Adapter&lt;/h2&gt;\n  &lt;p&gt;This card is rendered by a Web Component.&lt;/p&gt;\n&lt;/ui-card&gt;\n</code></pre> <p>You can also define the element from a <code>&lt;script type=\"module\"&gt;</code> tag when using a CDN, as shown in <code>getting-started.md</code>.</p>"},{"location":"usage/framework-integration/#2-react","title":"2. React","text":"<p>React can render Web Components as long as you follow a few conventions:</p> <ul> <li>Use kebab-case tag names (e.g. <code>ui-card</code>).</li> <li>Pass primitive props via attributes.</li> <li>For non-string data, use refs or custom events.</li> </ul>"},{"location":"usage/framework-integration/#setup","title":"Setup","text":"<p>Make sure your Adapter components are defined once at app startup:</p> TypeScript<pre><code>// components/ui-card.ts\nimport { Adapter } from \"@devcapsule/adapter\";\n\nexport class Card extends Adapter {\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid currentColor;\n  `;\n}\n\nCard.define(\"ui-card\");\n</code></pre> <p>Then import that module somewhere near your React root (once):</p> TypeScript<pre><code>// main.tsx\nimport \"./components/ui-card\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\n  &lt;App /&gt;,\n);\n</code></pre>"},{"location":"usage/framework-integration/#usage-in-jsx","title":"Usage in JSX","text":"TSX<pre><code>export function Example() {\n  return (\n    &lt;ui-card css=\"border-color: rebeccapurple;\"&gt;\n      &lt;h2&gt;React + Adapter&lt;/h2&gt;\n      &lt;p&gt;Rendered as a Web Component.&lt;/p&gt;\n    &lt;/ui-card&gt;\n  );\n}\n</code></pre> <p>Notes:</p> <ul> <li>JSX accepts the <code>css</code> attribute as a string just like HTML.</li> <li>Events from inside the Web Component bubble like normal DOM events; you can use <code>onClick</code> on child elements or custom event listeners on the host via refs if needed.</li> </ul>"},{"location":"usage/framework-integration/#3-vue","title":"3. Vue","text":"<p>Vue (2.6+ with the Web Components config, or Vue 3) works well with custom elements.</p>"},{"location":"usage/framework-integration/#configure-vue-to-ignore-custom-elements-vue-3","title":"Configure Vue to ignore custom elements (Vue 3)","text":"TypeScript<pre><code>import { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport \"./components/ui-card\"; // defines &lt;ui-card&gt;\n\nconst app = createApp(App);\n\napp.config.compilerOptions.isCustomElement = (tag) =&gt; tag.startsWith(\"ui-\");\n\napp.mount(\"#app\");\n</code></pre>"},{"location":"usage/framework-integration/#use-adapter-components-in-templates","title":"Use Adapter components in templates","text":"Vue<pre><code>&lt;template&gt;\n  &lt;ui-card css=\"border-color: teal;\"&gt;\n    &lt;h2&gt;Vue + Adapter&lt;/h2&gt;\n    &lt;p&gt;This is a Web Component card.&lt;/p&gt;\n  &lt;/ui-card&gt;\n&lt;/template&gt;\n</code></pre> <p>Because Adapter components expose a DOM-based API (<code>css</code> attribute / property), you can control instance styles with bindings:</p> Vue<pre><code>&lt;template&gt;\n  &lt;ui-card :css=\"cardCss\"&gt;\n    &lt;slot /&gt;\n  &lt;/ui-card&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nconst cardCss = `border-color: orangered;`;\n&lt;/script&gt;\n</code></pre>"},{"location":"usage/framework-integration/#4-svelte","title":"4. Svelte","text":"<p>Svelte treats unknown tags as custom elements by default, so Adapter components slot in easily.</p> <p>Make sure your component definition module is imported once before use (for example, in your root file):</p> TypeScript<pre><code>// main.ts\nimport \"./components/ui-card\";\nimport App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.getElementById(\"app\")!,\n});\n\nexport default app;\n</code></pre> <p>Then use Adapter-based elements in Svelte templates:</p> Svelte<pre><code>&lt;script lang=\"ts\"&gt;\n  let border = \"dodgerblue\";\n&lt;/script&gt;\n\n&lt;ui-card css={`border-color: ${border};`}&gt;\n  &lt;h2&gt;Svelte + Adapter&lt;/h2&gt;\n  &lt;p&gt;Styled via the css attribute.&lt;/p&gt;\n&lt;/ui-card&gt;\n</code></pre> <p>Because <code>css</code> is just an attribute, normal Svelte bindings work as expected.</p>"},{"location":"usage/framework-integration/#5-general-tips","title":"5. General tips","text":"<p>Regardless of framework, a few rules keep things smooth:</p> <ul> <li>Define once, use anywhere</li> <li> <p>Import the modules that call <code>MyElement.define(\"my-element\")</code> exactly once per page.</p> </li> <li> <p>Prefer attributes for simple styles</p> </li> <li>For quick overrides, pass <code>css</code> as a string attribute or bound prop.</li> <li> <p>For complex logic, use imperative access via refs (React), <code>ref</code>s (Vue), or the DOM API.</p> </li> <li> <p>Be mindful of SSR / hydration</p> </li> <li>When server-rendering HTML, ensure the client defines Adapter components before hydrating.</li> <li> <p>Adapter relies on <code>adoptedStyleSheets</code>; check your target environments if you need to support very old browsers.</p> </li> <li> <p>Use a unique tag prefix</p> </li> <li>Namespacing (e.g. <code>ui-card</code>, <code>ac-button</code>) avoids collisions with other components on the page.</li> </ul> <p>For concrete DOM and styling behavior, revisit <code>getting-started.md</code> and <code>core-concepts.md</code>, which map directly to the implementation in <code>src/adapter.ts</code>.</p>"},{"location":"usage/getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing Adapter, creating your first component, and understanding the basic styling model.</p> <p>If you haven\u2019t yet, read <code>intro.md</code> for the high-level concepts and motivation.</p>"},{"location":"usage/getting-started/#1-install-adapter","title":"1. Install Adapter","text":"<p>Adapter works in browsers, Deno, and Node-based bundlers. Choose the setup that matches your project.</p>"},{"location":"usage/getting-started/#cdn-browser-only-great-for-demos","title":"CDN (browser-only, great for demos)","text":"<p>You can load Adapter directly from a CDN in any HTML page:</p> HTML<pre><code>&lt;script type=\"module\"&gt;\n  import { Adapter } from \"https://cdn.jsdelivr.net/npm/@devcapsule/adapter/+esm\";\n\n  // your components go here\n  class HelloCard extends Adapter {}\n\n  HelloCard.css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid currentColor;\n  `;\n\n  HelloCard.define(\"hello-card\");\n  document.body.innerHTML = \"&lt;hello-card&gt;Hello Adapter&lt;/hello-card&gt;\";\n&lt;/script&gt;\n</code></pre>"},{"location":"usage/getting-started/#deno-jsr","title":"Deno / JSR","text":"TypeScript<pre><code>import { Adapter } from \"jsr:@devcapsule/adapter\";\n</code></pre>"},{"location":"usage/getting-started/#npm-node-bundlers-via-jsr","title":"npm (Node / bundlers via JSR)","text":"<p>Use the official compatibility helper so npm stays in sync with the JSR release:</p> Bash<pre><code>npx jsr add @devcapsule/adapter\n</code></pre> <p>This command installs the compatibility package (published as <code>@jsr/devcapsule__adapter</code>) and adds the correct alias to your <code>package.json</code>, per the JSR npm compatibility guide.</p> <p>After installing you can import Adapter with its canonical name:</p> TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n</code></pre>"},{"location":"usage/getting-started/#2-your-first-adapter-component","title":"2. Your first Adapter component","text":"<p>The easiest way to use Adapter is to extend the <code>Adapter</code> base class and assign a CSS string to the class itself.</p> TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n\nclass Card extends Adapter {}\n\nCard.css = `\n  display: block;\n  padding: 1rem;\n  border-radius: 0.5rem;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  background: white;\n`;\n\n// Register the custom element\nCard.define(\"ui-card\");\n</code></pre> <p>Use it in HTML like any other custom element:</p> HTML<pre><code>&lt;ui-card&gt;\n  &lt;h2&gt;Welcome&lt;/h2&gt;\n  &lt;p&gt;This card is styled by Adapter.&lt;/p&gt;\n&lt;/ui-card&gt;\n</code></pre> <p>Behind the scenes (see <code>src/adapter.ts</code>):</p> <ul> <li>A class controller (<code>AdapterClassController</code>) collects the CSS assigned on the class.</li> <li>When you call <code>Card.define(\"ui-card\")</code>, Adapter</li> <li>registers the custom element with <code>customElements.define</code>, and</li> <li>creates a constructable <code>CSSStyleSheet</code> shared by all <code>ui-card</code> instances.</li> <li>This stylesheet is attached via <code>document.adoptedStyleSheets</code>, so every <code>ui-card</code> shares the same base styles.</li> </ul>"},{"location":"usage/getting-started/#3-class-level-vs-instance-level-styles","title":"3. Class-level vs instance-level styles","text":"<p>Adapter gives you two main ways to style components:</p> <ol> <li>Class-level styles \u2013 shared by all instances of a component.</li> <li>Instance-level styles \u2013 scoped to one specific element.</li> </ol>"},{"location":"usage/getting-started/#class-level-styles","title":"Class-level styles","text":"<p>Class-level styles are defined on the class itself:</p> TypeScript<pre><code>class Button extends Adapter {}\n\nButton.css = `\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0.5rem 1rem;\n  border-radius: 999px;\n  border: 1px solid transparent;\n  cursor: pointer;\n`;\n\nButton.define(\"ui-button\");\n</code></pre> <p>You can add more base styles later using <code>static addStyle</code>:</p> TypeScript<pre><code>Button.addStyle(`\n  &amp;:hover {\n    filter: brightness(1.05);\n  }\n`);\n</code></pre> <p>Adapter aggregates these class-level blocks and writes them into the shared class stylesheet managed by <code>AdapterClassController</code>.</p>"},{"location":"usage/getting-started/#instance-level-styles-via-js","title":"Instance-level styles via JS","text":"<p>Every element instance also owns its own constructable stylesheet, managed by <code>AdapterObjectController</code>.</p> <p>You can style a single instance from JavaScript:</p> TypeScript<pre><code>const card = document.createElement(\"ui-card\") as InstanceType&lt;typeof Card&gt;;\n\ncard.css = `\n  border-color: hotpink;\n`;\n\ndocument.body.append(card);\n</code></pre> <p>When you set <code>card.css</code>:</p> <ul> <li>Adapter ensures the element has a stable, UUID-based class name.</li> <li>It generates a selector like <code>ui-card.ui-card-1234 { ... }</code>.</li> <li>It writes that rule into the instance\u2019s own <code>CSSStyleSheet</code>.</li> </ul> <p>That stylesheet is attached to the element\u2019s root node (<code>document</code> or shadow root) through <code>adoptedStyleSheets</code>, so the styles are local to that instance.</p>"},{"location":"usage/getting-started/#instance-level-styles-via-the-css-attribute","title":"Instance-level styles via the <code>css</code> attribute","text":"<p>You can also set styles declaratively using an attribute. Adapter observes the <code>css</code> attribute and keeps it in sync with the instance stylesheet.</p> HTML<pre><code>&lt;ui-card css=\"border-color: rebeccapurple;\"&gt;\n  &lt;h2&gt;Styled via attribute&lt;/h2&gt;\n&lt;/ui-card&gt;\n</code></pre> <p>In <code>src/adapter.ts</code>, <code>AdapterObjectController</code> uses a <code>MutationObserver</code> to watch for <code>css</code> attribute changes and update <code>element.css</code> automatically.</p> <p>Next steps: read <code>core-concepts.md</code> for a deeper look at the controllers and mixin, or jump to <code>framework-integration.md</code> to see how Adapter fits into React, Vue, and other stacks.</p>"},{"location":"usage/patterns-and-recipes/","title":"Patterns and Recipes","text":"<p>This chapter collects practical patterns for building real-world UI with Adapter.</p> <p>Use it as a cookbook: skim for the scenario you need, copy the pattern, and adapt it.</p>"},{"location":"usage/patterns-and-recipes/#1-buttons-and-variants","title":"1. Buttons and variants","text":""},{"location":"usage/patterns-and-recipes/#basic-button","title":"Basic button","text":"TypeScript<pre><code>import { Adapter } from \"@devcapsule/adapter\";\n\nclass Button extends Adapter {\n  static css = `\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    padding: 0.5rem 1rem;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    cursor: pointer;\n    font: inherit;\n    background: black;\n    color: white;\n  `;\n}\n\nButton.define(\"ui-button\");\n</code></pre>"},{"location":"usage/patterns-and-recipes/#variants-via-attributes","title":"Variants via attributes","text":"<p>You can add variants with attribute selectors in class-level CSS.</p> TypeScript<pre><code>Button.addStyle(`\n  &amp;[variant=\"outline\"] {\n    background: transparent;\n    color: black;\n    border-color: currentColor;\n  }\n\n  &amp;[variant=\"ghost\"] {\n    background: transparent;\n    border-color: transparent;\n  }\n`);\n</code></pre> <p>Usage:</p> HTML<pre><code>&lt;ui-button&gt;Default&lt;/ui-button&gt;\n&lt;ui-button variant=\"outline\"&gt;Outline&lt;/ui-button&gt;\n&lt;ui-button variant=\"ghost\"&gt;Ghost&lt;/ui-button&gt;\n</code></pre> <p>Because these rules are class-level styles, they apply consistently to every instance.</p>"},{"location":"usage/patterns-and-recipes/#2-cards-and-layout","title":"2. Cards and layout","text":""},{"location":"usage/patterns-and-recipes/#card-component","title":"Card component","text":"TypeScript<pre><code>class Card extends Adapter {\n  static css = `\n    display: block;\n    padding: 1rem;\n    border-radius: 0.5rem;\n    border: 1px solid rgba(0, 0, 0, 0.12);\n    background: white;\n    box-shadow:\n      0 1px 2px rgba(0, 0, 0, 0.04),\n      0 2px 8px rgba(0, 0, 0, 0.06);\n  `;\n}\n\nCard.define(\"ui-card\");\n</code></pre>"},{"location":"usage/patterns-and-recipes/#layout-container","title":"Layout container","text":"TypeScript<pre><code>class Container extends Adapter {\n  static css = `\n    display: block;\n    max-width: 960px;\n    margin: 0 auto;\n    padding-inline: 1rem;\n  `;\n}\n\nContainer.define(\"ui-container\");\n</code></pre> <p>Usage:</p> HTML<pre><code>&lt;ui-container&gt;\n  &lt;ui-card&gt;\n    &lt;h2&gt;Inside container&lt;/h2&gt;\n    &lt;p&gt;Adapter makes layout components easy to reuse.&lt;/p&gt;\n  &lt;/ui-card&gt;\n&lt;/ui-container&gt;\n</code></pre>"},{"location":"usage/patterns-and-recipes/#3-instance-specific-overrides","title":"3. Instance-specific overrides","text":"<p>Sometimes you want one-off custom styling without adding new variants.</p>"},{"location":"usage/patterns-and-recipes/#via-the-css-attribute","title":"Via the <code>css</code> attribute","text":"HTML<pre><code>&lt;ui-card css=\"border-color: hotpink;\"&gt;\n  &lt;h2&gt;Special card&lt;/h2&gt;\n  &lt;p&gt;Styled via the css attribute.&lt;/p&gt;\n&lt;/ui-card&gt;\n</code></pre>"},{"location":"usage/patterns-and-recipes/#via-the-css-property","title":"Via the <code>css</code> property","text":"TypeScript<pre><code>const card = document.createElement(\"ui-card\") as Card;\n\ncard.css = `\n  border-color: seagreen;\n  background: #f0fff4;\n`;\n\ndocument.body.append(card);\n</code></pre> <p>Under the hood (see <code>src/adapter.ts</code>), Adapter gives this instance its own constructable <code>CSSStyleSheet</code>, keyed by a stable UUID, and writes the rules there. Other cards are unaffected.</p>"},{"location":"usage/patterns-and-recipes/#4-nested-content-and-selectors","title":"4. Nested content and selectors","text":"<p>Adapter lets you target content inside your components using normal selectors.</p> TypeScript<pre><code>class Dialog extends Adapter {\n  static css = `\n    display: block;\n    padding: 1.5rem;\n    border-radius: 0.75rem;\n    background: white;\n  `;\n}\n\nDialog.addStyle(`\n  &amp; h2 {\n    margin: 0 0 0.5rem;\n    font-size: 1.2rem;\n  }\n\n  &amp; footer {\n    margin-top: 1rem;\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.5rem;\n  }\n`);\n\nDialog.define(\"ui-dialog\");\n</code></pre> <p>Usage:</p> HTML<pre><code>&lt;ui-dialog&gt;\n  &lt;h2&gt;Confirm action&lt;/h2&gt;\n  &lt;p&gt;Are you sure you want to continue?&lt;/p&gt;\n  &lt;footer&gt;\n    &lt;ui-button variant=\"ghost\"&gt;Cancel&lt;/ui-button&gt;\n    &lt;ui-button&gt;Continue&lt;/ui-button&gt;\n  &lt;/footer&gt;\n\n&lt;/ui-dialog&gt;\n</code></pre> <p>Selectors like <code>&amp; h2</code> are expanded by Adapter\u2019s CSS helper into valid rules scoped to your component.</p>"},{"location":"usage/patterns-and-recipes/#5-hostile-css-environments","title":"5. Hostile CSS environments","text":"<p>Adapter is especially useful when you embed UI into pages you don\u2019t control: dashboards, CMSes, plugins, or AI-generated layouts.</p> <p>Patterns:</p> <ul> <li>Namespace your tags</li> <li> <p>Use a prefix such as <code>ac-</code> or <code>ui-</code> for all Adapter components.</p> </li> <li> <p>Keep core styles at the class level</p> </li> <li>Define layout, typography, and basic tokens in <code>static css</code> and <code>static addStyle</code>.</li> <li> <p>Reserve instance-level <code>css</code> for overrides and local tweaks.</p> </li> <li> <p>Use attributes instead of global classes</p> </li> <li>Prefer selectors like <code>[variant=\"danger\"]</code> or <code>[size=\"lg\"]</code> rather than relying on global class names.</li> </ul> <p>Because Adapter writes rules into constructable style sheets attached via <code>adoptedStyleSheets</code>, your component styles will not be polluted by the host page\u2019s CSS, and vice versa.</p>"},{"location":"usage/patterns-and-recipes/#6-theming-and-design-systems","title":"6. Theming and design systems","text":"<p>Adapter can sit at the base of a small design system.</p> <p>Common patterns:</p> <ul> <li>Token helpers in JS/TS</li> <li>Create functions that return CSS strings, then feed them into <code>static css</code> or <code>addStyle</code>.</li> </ul> TypeScript<pre><code>const primaryColor = \"#2563eb\";\n\nconst buttonBase = () =&gt; `\n  border-radius: 999px;\n  font-weight: 500;\n`;\n\nclass PrimaryButton extends Adapter {\n  static css = `\n    ${buttonBase()}\n    background: ${primaryColor};\n    color: white;\n  `;\n}\n\nPrimaryButton.define(\"ds-primary-button\");\n</code></pre> <ul> <li>Shared layout primitives</li> <li> <p>Build reusable components like <code>Stack</code>, <code>Inline</code>, <code>Grid</code> as Adapter elements and compose them in any framework.</p> </li> <li> <p>Gradual adoption</p> </li> <li>Start with a single Adapter component (e.g. a card or button) embedded in an existing app.</li> <li>Expand to a small kit of primitives over time.</li> </ul>"},{"location":"usage/patterns-and-recipes/#7-progressive-enhancement","title":"7. Progressive enhancement","text":"<p>Adapter components degrade gracefully when styles are missing or not yet applied, which makes them friendly to progressive enhancement.</p> <p>Suggestions:</p> <ul> <li>Serve basic HTML content first.</li> <li>Define and register Adapter components as soon as your JS loads.</li> <li>Use Adapter for layout and polish, not for critical content visibility.</li> </ul> <p>If you work in a server-rendered environment, revisit <code>framework-integration.md</code> for SSR and hydration considerations.</p>"}]}